https://github.com/LinkedInLearning/ruby-on-rails-models-and-associations-2488472
git switch 01_01b
rails lil:import

From the command line, navigate into the project directory, and run bundle install to install the RubyGems. Next, add the database credentials to the database YML file in the config directory and run rails db:create. You can run rails lil:import anytime you want to get the database data in the same state as mine.

SMARTER MODELS

Smart models by design

In this chapter, we will learn how to make our models smarter. We'll begin by considering how we determine what code should be put into a model. There's a common saying in the Ruby on Rails community, "Fat model, skinny controller." It means that it's usually better to move business logic out of the controllers and into your models. Your models become smarter, and that business logic can be called anywhere in your application without repeating yourself. All it requires is an instance of the model. We should consider what things an instance of the class should know about, or know how to do, and then define methods for them. Then those methods can make good use of the attributes and associations that are already inside the model. Here's a common and simple example. This controller finds a user and then sets a variable for the page title to the user's full name. You can imagine that the full name will be used often. Several of the view templates may also use it. If it will be used often and in the same way each time, shouldn't a user object know how to construct its own full name? It's very simple business logic but it illustrates the point. It would be better to move that logic to the user class. We can define a full name method that contains the logic to assemble it from the parts. Now, any instance can be asked for a full name. There's no need to repeat that simply process each time. The logic here has slightly better handling of a missing first or last name too. If we were to make more changes to the logic, it would be changed everywhere at once. The user object becomes smarter. Here's another example. An instance of the order class can be asked if it's recent or not. It knows what's considered recent, and it knows how to perform the calculation. Canceling order may be a multi-step process. A controller could perform those steps, but shouldn't an order know how to cancel itself? It can perform whatever housekeeping tasks or logging that it needs to do in the process. And then our controller becomes streamlined. The code is easy to read and the mechanics are taken care of behind the scenes. If more than one controller needs to cancel orders, we don't have to repeat ourselves and risk making mistake or having several versions that get out of sync over time. One hint that code may be better inside a model is when you find yourself passing model attributes around the controller. A model always has its attributes on hand. There's no need to pass them. In this example, a profit report finds a report in the database and then passes the start and end dates to methods which calculate the income and expenses. If a report already knows its start and end dates, it seems like the income expenses and profit or information the report object should know how to calculate and be able to tell us when asked, the controller is doing the model's work. If we were to move these calculations into the model that every report object becomes smarter. And we don't have to pass around the start and end dates anymore, the income and expenses methods can access those attributes easily. And the controller can be thin. It just finds the report. Given any report instance, any view template can ask it for the income, expenses, or profit. These examples show the benefits of moving business logic to models. We don't repeat ourselves which it produces the amount of code and organizes it well. Dry code is easier to maintain and reduces the chance for bugs and inconsistencies. The business logic in model methods can be called throughout the application. It's also handy that it's easier to work with in the rails console, and easier to write code to test the logic to make sure that everything is working is expected, but that the same time, don't get carried away. Code for decisions about how to respond to user actions still belong in a controller and code for presenting data still belongs in the views. If you have complex formatting logic you should put it in view helpers. If you find that you're putting HTML, CSS, XML, JSON, or JavaScript into your models, it's a sign that you may have moved too much. Those are for formatting data and responding to user requests. The exercise files include a Ruby on Rails application which is based on the project we created in Ruby on Rails essential training and worked on in Ruby on Rails controllers and views. Let's add a user model, and we'll give it columns for the first name, last name, and email. Generate model, user, first name, string, last name, string, and email string. We see that it created a new migration for us here, and we can run our migration with rails db migrate. And we see that we also have a model here for user. So let's go into the user model and let's add a couple of methods. Let's go ahead and add that full name method, and we can do it the same way that I did it on the slide. First name, last name, and we will join them together with a space. Let's also copy that, and let's make another version of it which we will call, "last name first." It's the same thing, but we will just take the last name and put the first name after it. Still, instead of a space, let's join it with a comma. So it's comma space. And then let's add one more version here. I'll copy this. And I'm going to call this one, abbrev name for abbreviated name, and we'll find the first initial for the person by taking the first name characters first, and we'll add to it a period space, and then we'll take the first initial and put it here as well. So now we have three methods. We've made our user model smarter because it can put together the data and construct it in different ways. So let's save it and let's go over here and try it in the rails console. One of the handy things about making models smarter is that we can try things here. We don't have a user yet since we just created one, so let's create a user. User create and you can can give it any name you want. I'm going to call mine Kevin and last name Skoglund. And for the email, I'll put in someone@somewhere.com. Now, I created the user so now we can do user full name, user last name first, and user abbrev name. Now, these are just very simple examples. Obviously in your application, you're going to put a lot more complex logic here. But even these simple methods make the point that it's better to move business logic out of your controllers and into your models.