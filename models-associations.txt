https://github.com/LinkedInLearning/ruby-on-rails-models-and-associations-2488472
git switch 01_01b
rails lil:import

From the command line, navigate into the project directory, and run bundle install to install the RubyGems. Next, add the database credentials to the database YML file in the config directory and run rails db:create. You can run rails lil:import anytime you want to get the database data in the same state as mine.

SMARTER MODELS

Smart models by design

In this chapter, we will learn how to make our models smarter. We'll begin by considering how we determine what code should be put into a model. There's a common saying in the Ruby on Rails community, "Fat model, skinny controller." It means that it's usually better to move business logic out of the controllers and into your models. Your models become smarter, and that business logic can be called anywhere in your application without repeating yourself. All it requires is an instance of the model. We should consider what things an instance of the class should know about, or know how to do, and then define methods for them. Then those methods can make good use of the attributes and associations that are already inside the model. Here's a common and simple example. This controller finds a user and then sets a variable for the page title to the user's full name. You can imagine that the full name will be used often. Several of the view templates may also use it. If it will be used often and in the same way each time, shouldn't a user object know how to construct its own full name? It's very simple business logic but it illustrates the point. It would be better to move that logic to the user class. We can define a full name method that contains the logic to assemble it from the parts. Now, any instance can be asked for a full name. There's no need to repeat that simply process each time. The logic here has slightly better handling of a missing first or last name too. If we were to make more changes to the logic, it would be changed everywhere at once. The user object becomes smarter. Here's another example. An instance of the order class can be asked if it's recent or not. It knows what's considered recent, and it knows how to perform the calculation. Canceling order may be a multi-step process. A controller could perform those steps, but shouldn't an order know how to cancel itself? It can perform whatever housekeeping tasks or logging that it needs to do in the process. And then our controller becomes streamlined. The code is easy to read and the mechanics are taken care of behind the scenes. If more than one controller needs to cancel orders, we don't have to repeat ourselves and risk making mistake or having several versions that get out of sync over time. One hint that code may be better inside a model is when you find yourself passing model attributes around the controller. A model always has its attributes on hand. There's no need to pass them. 

In this example, a profit report finds a report in the database and then passes the start and end dates to methods which calculate the income and expenses. If a report already knows its start and end dates, it seems like the income expenses and profit or information the report object should know how to calculate and be able to tell us when asked, the controller is doing the model's work. 

If we were to move these calculations into the model that every report object becomes smarter. And we don't have to pass around the start and end dates anymore, the income and expenses methods can access those attributes easily. And the controller can be thin. It just finds the report. Given any report instance, any view template can ask it for the income, expenses, or profit. 

These examples show the benefits of moving business logic to models. We don't repeat ourselves which it produces the amount of code and organizes it well. Dry code is easier to maintain and reduces the chance for bugs and inconsistencies. The business logic in model methods can be called throughout the application. It's also handy that it's easier to work with in the rails console, and easier to write code to test the logic to make sure that everything is working is expected, but that the same time, don't get carried away. Code for decisions about how to respond to user actions still belong in a controller and code for presenting data still belongs in the views. If you have complex formatting logic you should put it in view helpers. If you find that you're putting HTML, CSS, XML, JSON, or JavaScript into your models, it's a sign that you may have moved too much. Those are for formatting data and responding to user requests. 

The exercise files include a Ruby on Rails application which is based on the project we created in Ruby on Rails essential training and worked on in Ruby on Rails controllers and views. Let's add a user model, and we'll give it columns for the first name, last name, and email. Generate model, user, first name, string, last name, string, and email string. We see that it created a new migration for us here, and we can run our migration with rails db migrate. And we see that we also have a model here for user. So let's go into the user model and let's add a couple of methods. Let's go ahead and add that full name method, and we can do it the same way that I did it on the slide. First name, last name, and we will join them together with a space. Let's also copy that, and let's make another version of it which we will call, "last name first." It's the same thing, but we will just take the last name and put the first name after it. Still, instead of a space, let's join it with a comma. So it's comma space. And then let's add one more version here. I'll copy this. And I'm going to call this one, abbrev name for abbreviated name, and we'll find the first initial for the person by taking the first name characters first, and we'll add to it a period space, and then we'll take the first initial and put it here as well. So now we have three methods. We've made our user model smarter because it can put together the data and construct it in different ways. So let's save it and let's go over here and try it in the rails console. One of the handy things about making models smarter is that we can try things here. We don't have a user yet since we just created one, so let's create a user. user = User.create(first_name: '', last_name: '', email: '') and you can can give it any name you want. I'm going to call mine Kevin and last name Skoglund. And for the email, I'll put in someone@somewhere.com. Now, I created the user so now we can do user full name, user last name first, and user abbrev name. Now, these are just very simple examples. Obviously in your application, you're going to put a lot more complex logic here. But even these simple methods make the point that it's better to move business logic out of your controllers and into your models.

More ActiveRecord query methods

In this movie, we will learn more ActiveRecord query methods so that we can find records more efficiently. In the Ruby on Rails Essential Training, we learned a query for records using where. It can accept a string, an array, or a hash. I like to use a hash when I can. when the hash has several elements, Rails will join them into an SQL query using AND. We can also daisy chain several where clauses together, and Rails will also join them, using AND. That's especially useful when one of the queries uses a hash, and the other uses something else. In this example, the second query uses an array 'cause it includes a greater than in the where clause. Chaining clauses is possible because Ruby on Rails does not fire off the database query right away. It waits until it's needed. This example chains two queries, and assigns the query to the variable products, but it still does not execute the query. Further down in the code, if either of two conditions are met, it will chain on additional where clauses. Each time it calls the where method on the existing variable, and assigns the result to the same variable name. This is a common and useful pattern. You can also write an AND clause using the AND method. It is a little more cumbersome. It takes a query as an argument, which is why you see the product class being used twice. It must use the same model, and it should only have a where clause. This is most useful when you already have one query defined for another purpose, and then you want to incorporate it into another query. All three of these examples would execute the same SQL. It's useful to see how that AND method works, because that's how the OR method works too. You can't write an OR clause without using the OR method. Personally, I find this second form to be more readable. Remember it's not actually making two queries. The first query is defined, but not executed unless it's needed. When we use an AND clause, we are narrowing the possible results. When we use an OR clause, we are expanding the possible results. Ruby on Rails also has a NOT method that can be added to a where clause. It negates the contents of the clause. You can see how the SQL adds NOT right after AND. Of course, you could reverse the contents of the query instead, but sometimes this will be more readable in your code. Let's test drive them. Even without a lot of records in our database, we can still go into the Rails console and see the SQL that's generated by the queries. We have a task model, we do task dot all. You can see them all in there. And if we scroll to the top, you can see the SQL that it generates. If we do task where completed false, we'll get a where clause added. 

Now, we actually are seeing the results in executing it, but we also could put two underscore SQL at the end, and that will not execute the query, but just show us what the SQL would be. That can be helpful. So let's try another version, where we just come up here and add into it that the category ID should be one. And you can see the SQL that it generated, and you can see that it added an and there. We can also try assembling two together. Let's do tasks equals task dot where completed is false, and where created at is greater than something, and that will be one month ago. And I'll hit return. Now the console fired that request immediately because we're in the console. It went ahead and executed it because it assumed it was needed. If we were in our application code, it would not have fired that request yet. It would wait until it was actually needed for some other purpose. It's a kind of a quirk of working in the console. We can go ahead and add onto that, using tasks equal tasks dot where, category ID is one. You see here that I'm using tasks and tasks twice. I'm just calling where on it, and assigning it to the same variable name. And you can see that it assembled it with and, an and. Let's try using the AND method. I'm going to make something called undone, which is task dot where completed is false. Let's imagine that I have this for some other purpose in my application. And then I could have something else that says task where category ID is one and undone. So I'm passing in that scope from above, and it will combine them together. Select task where category ID is one and completed is false. And that same thing works with OR, category ID one or undone. If we scroll up here a little bit, you can see that it adds in category ID one or task completed is false. And then let's just try one that's a NOT. Let's try task dot where not category ID one, so all the other categories besides this one. Using these query methods will make it easier for application code to find records efficiently.

To display your results in a way that can be paginated use the offset keyword. This keyword is used to start the results at a different position other than the first record. This can be used to code for pagination.

Select data from a query

In this movie, we will learn how to refine a query so that we retrieve the data our application needs as efficiently as possible. The simplest selections are all, first, and last. It's usually not necessary to use all at the end of a query because it's implied, but all is useful when there is no other query method or when we want to cause the query to execute right away. It will return an array. The first method will limit the query to one record and then return an object instead of an array. The last method does the same thing but reverses the sort order so that what was the last record becomes the first. These methods return instances of models, either a single object or an array of them. For each row, return from the database by the query. Active record will create a new instance of the object and populate it with the values of that row. As developers, we need to be mindful of the workload that requires. It's insignificant when there are 20 records but it's substantial when there are 20,000. Notice the difference between these queries. The first query is retrieving every customer record, even if there are 20,000, and it spends time populating values for Ruby objects for each one and holding them in memory. But the next line is only using the first five objects. The others were wasted effort. The second query returns only the five records we want and it only dedicates time and memory to those five objects. It can be much faster. The first and last methods can also accept an argument for the same result. The same is true if we don't actually need the records at all. We can use count to get back only the number of matching records. This is much faster than retrieving all records and measuring the length of the array. Rails also provides any and none which will test for returned row without creating any objects, and many and one that use a variation of the count to tell you if there's one record or more than one record Rails is also smart about using the results of previous queries to find these values if they're already available. There are also several methods for returning partial data from a matching row. A query typically selects all columns from a table but the select method limits the SQL to the columns listed as arguments. This example is selecting only the ID and name columns. This will retrieve less data when there are many columns in the table. It still creates an instance of the class using those values, but any of the other attributes will not be available. This may be useful for some cases, but more often it's better to work with objects that have all of their attributes. For selected values, the pluck method is usually a better choice than select. The SQL is the same. It also selects only the listed attributes but it returns an array of the values, not objects. The result is similar to querying for many objects and calling map on the collection, but it's much more efficient if those are the only values that we need. The IDs method is a shorthand for plucking the ID from each row and returning them as an array. If you just need the IDs, it's much more efficient than retrieving all objects and then making an array out of them. Let's try these out. Let's go into our Rails console and let's just try our task model and we'll call all on it. And we already know that that's going to give us back all of the records that are there, right? It's going to find everything and it's going to instantiate Ruby objects for each one using the values from those rows. Task dot first. You can see the SQL it generates. It just finds one record. Only one. It doesn't create a full array. It just finds one and gives us back just that object, not an array of objects. And task last does the same thing but it reverses the order before it gives it back to us. So let's try setting tasks equal to task all. We're going to get back all of the objects that are there. We know how many are there because we can put task count on it. There are four. So let's find less than that. Let's do tasks zero to two, right? So that's just going to gimme back three objects. So now I've created a fourth object that I never used. Let's try instead to do tasks by task, limit three. Now it's only finding the three objects that I need to begin with. That fourth object, it didn't create and then discard. And we can do the same thing if we do first three. It does the same thing as if we do limit three. Let's try another one where we do task dot where completed is false. Let's see how many of those there are. We have three of them. We can also use any. We know there are some, so it says, yes, there are. If I say none, I'm asking it, are there none? It comes back and says false, there are none. Notice here in each case, it's selecting one as one from the tasks and it's doing limit one also. It's just asking for one record. So one record, just tell me if it's there or not. And then we have the variations. We have many and one. These are essentially asking for the count to find out whether there's one record or many record. Let's try with select. Let's create a task with task dot select ID and name and completed. And we'll just do the first for it so we just get back one. Now, if we do task dot name, the name is there. But if we do task dot description, it's not there. We get a missing attribute error. It's like we have a half functional object. Sometimes that might work for you. But most of the time I think it's better to use task dot pluck and ask it to return back whatever it is you want. So name and completed, let's say. It will give you back an array of just those values. It doesn't try to create objects at all. It's just data. And we could also do task dot IDs if we just want to get back an array of IDs. So select the ID from tasks and it just makes an array of the result. These selection methods allow more efficient queries which can make your application faster.

Named scopes

In this movie, we will learn how to use named scopes in our models. When we discussed model design at the beginning of this chapter, we saw the benefits of moving commonly used logic into the models. Named scopes follow that principle. And they allow us to define commonly used queries in our models. You construct them out of the built-in query methods that we've been using, but they're stored as lambda functions, which create a block of code for later use. You won't use lambda functions often, but named scopes require them, and they're easy to learn. In this example, the Product class has a named scope. It uses the keyword scope, followed by a symbol for the name that we want to give it. And then there's a comma and an arrow created from a minus and a greater than sign. That arrow indicates that the block inside the curly braces is a lambda function. It holds code to be used later. We can use our named scope by calling it on a model, just as if it were a built-in query method. We've just wrapped it up and given it a name. We can chain named scopes together, just like we can other queries. The code is compact and very readable. Plus we don't repeat ourselves, which is better for maintaining bug free code. 

Named scopes can also accept arguments. You can define the block variable inside the curly braces, as you would any other code block, but to do that, you have to use the word lambda. If you use the lambda syntax with the arrow, the block variable goes outside the curly braces. 

The search scope here contains Ruby code in addition to the query. You can include as much Ruby code as you like, as long as the block returns an active relation query at the end. That ensures that another query can be chained onto it. Notice how the complexity of searching gets packaged up and hidden. 

In our controllers, we can just pass in a string to the scope, and the model holds all the logic that makes it work. 

Let's add some scopes to our project. For the User class, let's add a scope. I'll just put in the keyword scope. I'm going to give it the name of sorted, then a comma, then I'll use the lambda arrow, and then in curly braces, I'll put the code that I want to execute at a later time, order, and we'll make it last_name, first_name. So now I can call sorted as a query, and it'll just depend on this order clause. I'm going to copy that, and let's make a variation of that in our category. I'd like to put the scopes for sorted in most of my models, that tells me how I want to sort them by default. And this one, we'll just sort by name by default. And then let's go into task and we can add one here as well. This time, the task is going to sort by position. It has a position. So that's going to be its sort order. Let's add a few more to it. Let's add scope for task for when it's complete. And that will be the where clause for completed is true. And I'll copy that and paste in another one. I'll put in in for incomplete, where completed is false. And we have sorted, and let's add one for search, just so we can see what it looks like with search. If we're going to use the arrow, then we have to put the variable that we want to use here. So that's the block variable to use inside here, where, and let's do LOWER name is LIKE ?, and what we'll drop in there will be percent as wild cards, and then we'll drop in the string kw.downcase. Now, we could do more processing in here, but I'm going to keep it simple. Now let's save all of this and let's go over here and try it in our console, rails console. And we can have User.sorted. And you see it went ahead and just appended that ORDER clause on there. We can do Category.sorted. 

We can do Task.incomplete.sorted, and search for laundry, and it returned back the Task force. You can see the SQL that it assembled. And we got back this object because laundry is included in the name. Named scopes are powerful way to make common queries convenient.

The stabby Lambda syntax uses a hyphen followed by a greater than sign "->" in place of the word "Lambda" for shorthand.

Non-database attributes

In this movie, we will discuss the utility of non-database attributes in Ruby on Rails. In basic Ruby, we can create new instance of attributes with several methods, attr_reader, attr_writer, and attr_accessor. 

This example uses an attr_accessor for status. That line has the same effect as if we had defined both a reader and a writer method for status as you see written out below it. An attr_reader would have the same effect as the status method. An attr_writer would have the same effect as the status equals method. 

We can also use these types of custom attributes in our Rails models. After all, attributes are just methods to access values. They don't have to be values stored in the database. They can be preserved in memory. We can communicate information to an object and set a temporary state inside of it. We don't need to store that information long term in the database, but it can affect the values and behaviors of other methods. 

Let me give you an example. 

This Payment class has a database table associated with it. Rails will automatically provide attr_accessor methods for each of its columns. In addition, this class has an attr_writer method for card_number and an attr_reader method for transaction_error. These attributes do not have a database column to go with them. 

Further down, the code instantiates a new instance using payment parameters which is likely derived from a submitted form. Let's assume that the form had a field for card_number. Ruby on Rails will assign the form value to the attribute for card_number. It doesn't care whether the attribute uses database storage or not, and it's a good idea not to store a credit card number in the database. 

When the next line calls the process method, it uses the instance variable for card_number to charge the credit card and then sets any error in the return result to transaction_error. The code can then extract any transaction error, because we have an interface that lets us read it. 

You can see how these values are transient. They just exist as a temporary state inside the object. When the object is done, they disappear. 

Here's another example where payment has an attr_accessor for zone. When the request domain matches a European domain, it will use a European payment processor. If not, it uses an American payment processor. 

The zone attribute establishes a context or a mode for the object that affects its behaviors. You won't use them every day, but defining non-database attributes is a valuable technique to have in your toolbox. They can also be useful with validations and callbacks which we'll examine in the upcoming chapters.

DATA VALIDATIONS

Overview of validation methods

In this chapter, we will learn about validations, starting with an overview. Validations allow us to make sure that data meets a set of requirements before it is saved to the database. You can think of them as rules that our data must follow. We define these rules in our models. As we discussed in the last chapter, a model should know whether data is good or not, and it is best positioned to be the gatekeeper to the database. If data doesn't follow the rules, it will fail the validations and the record will not save. It will keep track of the errors, which is useful so the user can see what went wrong and try again. Rails includes many validation methods. They allow us to ensure that data exists and has the correct data type, value, or format. Here's an example of a validation inside a product class. Each one has the validation method with the attribute to be validated plus any options that it requires. Let's learn how each validation method works. The most common validation is validates_presence_of. It ensures that an attribute is not blank. It can't be nil, false, an empty string, a string of only spaces, an empty array or an empty hash. If we add a line to validate the name attribute and then try to save a record without a value for name, it won't be saved and an error message will be recorded. The validates_length_of validation ensures that an attribute has a certain number of characters. If we validate that the name is within the range from three to 40, then anything less than three or more than 40 will be rejected. It accepts options for is, minimum, maximum, and within. The validates_numerical_of method ensures that an attribute is a number, either an integer or a float. The options can specify equal to, greater than, less than, greater than or equal to, or less than or equal to. The validates_inclusion_of method ensures that an attribute is in a list of choices. To do that we need to provide it an array or range using in or within. In this example, status must be one of the strings that's included in the array. The opposite behavior is in the validates_exclusion_of method. In the example, zone ID cannot be either 78 or 109. The validates_format_of method ensures that an attribute matches a regular expression. This is handy for things like email addresses, URLs, phone numbers, and zip codes. The with option is used before the regular expression. This example validates that the zip code is five digits. The validates_uniqueness_of method ensures that an attribute is not already in the database. In this example, it ensures that every username will be unique. Now to confirm this, the validation must make a call to the database. The options can set case sensitive to true or false or provide a scope for the unique requirement. For example, you might scope this example validation by company ID, which would allow duplicate usernames as long as they aren't from the same company. The validates acceptance of method ensures that an attribute has been set. Its main use is to test if a checkbox on a form was checked. It will store the value if you have a column in the database, but if not, it will create a non database attribute that has no table column. So for example, you might have validates_acceptance_of some terms of service. You can also use the accept option to change what value it expects to receive, which is one by default. The validates_confirmation_of method ensures that an attribute has been confirmed by submitting it twice. You've probably done this for passwords or email addresses. You enter it once and then you enter it again. It creates a non database attribute so that it can receive the duplicate confirmation value without needing a column in the database. It also only validates when that value is not nil. That means that if you don't include a form input for it then it won't run this validation. A customer facing page might require confirming their password while an admin facing page might not. The validates_associated method ensures that the associated objects are also valid. We'll talk more about associations in a later chapter. But this method says before one object can be considered valid, we must check all the associated objects too. The first argument is the association name, not an attribute. It will call the valid method on any of the associated objects. However, it does not fail if the object does not exist, only if it exists and is not valid. You may want to parrot with validates_presence_of if the object must also exist. Be careful not to create infinite loops or long cascades. If one object requires an associated object to be valid, the associated object should not require the other object to be valid, or they'll keep asking each other in circles. Most validation methods accept a few standard options. You can pass in allow nil or allow blank. You can specify that the validation should run anytime a record is saved, only when a new record is created, or only when an existing record is updated. You can use if and unless to set conditions for the validation. The default error messages are pretty good but you can also customize them by setting the message option. In the next movie we'll try using these in our project.

Write validations

Now that we have an overview of validations, we will add some to our project, but first, let's consider what data should be validated. Deciding what to validate requires asking what your data concerns are. The concerns will be different for each project and for each model. A good starting point is to consider what good and bad data look like. Consider what restrictions your database imposes. A model should block data that the database won't accept before it tries sending it. Ask yourself what data would stop your application from working correctly. Your code may include assumptions about data being present in a certain format or with a certain value. It may take a little while to get a feel for it, but you can start simple and add more validations over time. Typically you won't need to validate low level data like IDs, foreign keys, timestamps, or boolean. Those are simple enough that they don't require it. Let's add validations to the user model. What should we validate? A user should probably always have a first name and a last name. In fact, you'll notice that the brev name method that we created earlier would run into an error here if the first name is blank. We could change the code or we can use a validation to ensure that a value exists. Let's do that by adding a line up here validates the presence of first name. I'm also going to add another validation to validate the length. Validates length of first name, and we're going to provide it with an option here, and I'm going to use minimum of one. Now, I picked one specifically so that I can show you the difference between validating the presence and validating the length. Let's save it and let's go into the rails console and try it out. So let's start by creating a new user, and let's just try to save that user to the database. It returned false. It prevented saving it because of our validation. And we can see the problem. If we use user.errors, and we'll get back an array of the errors. Now, it's not a very friendly format, but you get the idea that the first name was blank, and the first name was too short. More user friendly errors that we might show to users, we can get with user.errors.full_messages. And now you can really see first name can't be blank. First name is too short. Minimum is one character. You can see that the two messages are different. Notice that it ran both validations. It runs all of them and reports all errors. It doesn't find the first error and stop. It would be annoying if there were several errors and a user had to submit a form several times in order to find and fix them all. Let's try adding a first name now. User.first_name, and I'm just going to use test. Now, I'm not going to save it. Instead I'm going to use user.valid? to find out if it would save. That's the same method that save calls to find out if it's okay to save it or not. So user.valid return true. So this object is saveable to the database. It passes the validations. Let's try another example. User.first_name equals, and I'm just going to put five spaces inside the quotes. Now let's ask whether user is valid. This time it's not. Why not? Let's go up and let's check the full messages. The first name can't be blank. It passed the length validation but not the presence validation because an empty string is considered blank or not present. Let's exit the console and go back to our code. Now, I'm also going to add a validation here for validates the presence of last name as well. You can leave the linked one or you can change it to something else if you want. I've also gone ahead and added some validations here as examples for task to validate the presence of the name, the length of the name with the maximum, the presence of the position, and the numericality of the position should be greater than zero. For category, I've added one to validate the length, and it's within two and 50. You can try these out on your own. I want to mention that our project already has code to display errors on the category and task. If we go into our views on the task form, you can see we're calling error messages for, that's actually a helper method that we define here in application helper which renders a partial layout's error messages. And if we go look at that, you can see that it is outputting the errors. The most important part is right here. Object.errors.full_messages just like we were doing. We're going to output the errors so we can call this helper method any time we want to display the errors on an object. Now we know how to write validations and how to display errors to the user. Good validations will improve the quality and consistency of the data in your application.

Use the multipurpose validates method

We've learned the basic validations. In this movie I want to show you a different way to write them that can sometimes be more convenient. This user class has five validations all on the email attribute. It validates the presence, the length, the uniqueness, the format, and the confirmation. These same five validations on email can be written as one line behind the scenes. Rails sets up the five validations that we saw in the previous example. This version is just a concise way to write them. It's less typing and you may find it easier to read. I indented them to show them clearly but that's not necessary. It begins with a new method called validates and then the attribute and then a hash. The keys of the hash are the validations that should be applied. And the values are either options for the validation like the options on length in this example or simply the value true. Here, we see the validates method with all of the validations that we've learned. It can have presence, numericality, length, format, inclusion, exclusion, acceptance, uniqueness, and confirmation. You can see that length, format, inclusion, and exclusion expect options. The other validations, the one where the value is true, those will also accept a hash which is where you would put other options like customizing the error message that it uses. Let's try them in our project. I've already added these to the exercise files so that you don't have to watch me type them all. I've included a constant that's just a basic regular expression that'll check whether something matches a typical email address. Notice that instead of having the validates presence of, I now have validates first name, presence true. That'll do the same thing. And instead of having a separate line for validates the first name's length, I can now just include it as another option, length, maximum 25. I've done the same thing for last name. Presence true with a length that's maximum 50. And then for the email, we'll make sure that it's present, that its length is not over 100, that it is a unique value, that it matches the format of the regular expression, and that the confirmation is true if it's sent in. Now, you can still mix and match these with the other style of writing validations. You can see I added one down here that's validates acceptance of terms. In this case I think it's easier to write it this way than it is to use the validates method. Let's test drive them. 

Let's go into the rails console and now let's try and create a user with user.new. We can check user.valid. It comes back and says it's not. User.errors.full_messages. And you see that it comes back and tells me all of these. It runs the exact same validations that it had before. Let's try user email equals nothing and then let's try user valid. And then if we go up and check the error messages, you'll see that this time it's not that the email can't be blank but it's still an invalid email. That's the message returned. We also get to see that it actually went and checked the database to see whether it was a unique email or not. So it made this SQL query here to find out whether the user with email nothing was existing in the database. We now know two ways to write validations. They work the same, which one you choose is a matter of the context and your personal style.

Creating an input value of four whitespaces and applying the rules validates_presence_of and validates_length_of with a minimum length of four as a test, makes results 

  validates_presence_of is false, and validates_length_of is true

The first rule returns false because whitespace is considered blank. (The validation rule "validates_presence_of" makes sure that a value is supplied and is not blank.) The input has a length of four characters, so the second rule is true.  

Write custom validations

The built-in validations are powerful and cover most of your needs, but sometimes there are special cases that require writing custom validations. We can do that with the validate method. Notice that it is singular, not plural like the validates method we used in the last movie. After that, we provide a symbol, which is the name of the custom validation method we want to run. Like the other validations we learned, the custom validation can use options to run it for every save or just for create an update actions. Inside that custom method, you can put any code you want, but it usually has two features. It includes some kind of test case that will be true or false. And if it's true, the method will add an error to the object's errors array. This is how the built in validations work, too. They run test cases and add errors if the test fails. When the validation process ends, having any errors indicates the object is not valid. We add errors with the add method, the attribute we want to add it to, and the message to show the user about the nature of the error. The custom method could perform several tests and add several errors, but I recommend making them separate whenever possible. Let's try an example. Let's write a validation on our task model and I'll put it right here. Let's validate singular that the description has no prohibited words. It's a long name, so I'm going to copy it. I'm going to drop down here. I'm going to make a private method for the same thing. I make it private because nothing else really needs to call it except this class. So descriptions has no prohibited words. Now we may not have a description. A description is not required. There's no validation for it. We made it optional. So I'm going to add a line that says return unless the description is present. And then I'm going to make a list of the prohibited words. "Prohibited words". And the prohibited words I'm going to use are procrastination words. This is a to-do list, task manager. So I'm going to prohibit using anything that might suggest that I'm going to procrastinate. You can make it anything you like. And then we'll take those prohibited words and we'll iterate through them for each one. And inside, let's check to see if the description includes it. We'll do that with if description.include and then word. And what do we want to do if it does include it? We want to add an error onto the error's array with add. We're going to add it for the description so it is attached to the problem attribute and then comma and then a fragment sentence that starts with the description. So the description cannot contain prohibited word and because I'm using double quotes there, I can interpolate a value and I'm actually going to input the word so that we can actually see what the word is in the error message so that we know what the problem was. Otherwise, it might be a bit of a mystery where we used some words prohibited, but we don't know which word it was. So let's put that in there. Now let's save it and let's go try it out. We'll go into our terminal. We'll run the rails console. And let's start by creating a new task. Task.new, and we'll give it a name. I'll just make it test. And we'll go ahead and give it a position of 10. But I won't give it a description yet. Let's check and see. Task.valid. Yes, it is valid. Let's try adding a description. Task.description and let's just make our description test. Is that still valid? Yes, it is. Now let's try and make it test later. And when I check, it's false. It's not valid. And if I call task.errors.full messages you'll see, "Description cannot contain prohibited word later." Notice how it assembled the name of the attribute with that fragment that we provided, too. It's easy to create custom validations by using the validate method to add errors to the object if a test case fails.

ACTIVERECORD CALLBACKS

Overview of callbacks

In this chapter, we will learn about callbacks, beginning with an overview of how they operate. Callbacks allow us to intervene in an object's life cycle. It's as if the standard code pauses at key moments to check in with you to see if there's custom code that you'd like it to run before the process continues. Callbacks will run code automatically before or after an object is created, updated, or destroyed. This chart helps explain how they work. There are three columns for creating, updating, and destroying an object. If you read down each column, you will see where we can intervene. Let's start by looking at the first column for create. Our first opportunity to intervene is before the object is validated. Validation happens before every creator update action. If we use a before_validation callback, it will run our code and then proceed to the validation. For example, our code could add default values to help an object pass its validation. We get another intervention point right after the validation. The most useful and common validations are the ones before and after the database interaction, where it either creates, updates, or destroys a record in the database. Create has two callbacks, before_save and before_create. If you look over at the center column, you'll see why there are two. If you write a before_save callback, that code will run when the object is created or when it's updated. If you write a before_create callback, it will only apply to object creation. The database interaction takes place after those two callbacks. And then we get two more, after_create and after_save, and they follow the same logic as before_save and before_create. One applies to any save and the other is just to an object's creation. And then there's a third callback, after_commit, which is somewhat new but useful. Ruby On Rails wraps the database interaction in a transaction. If anything goes wrong with the changes that it sends to the database, it can undo those changes. That's useful if changing one record in the database is triggering other changes to other records at the same time. The changes are a set and changes in the set are not completely committed to the database until all of the changes are complete. Some changes could still be rolled back. The after_create and after_save callbacks take place inside the transaction, after the change to one object has succeeded but before we're sure that everything is finalized. The after_commit callback is the point where the changes are completely done. As an example, if we wanted to send an email after an object is created, we should do it in an after_commit to be certain that the save was successful. The column of update callbacks is similar to the create column. The column for destroy callbacks is simpler. Notice that it also executes any after_commit callback. These callbacks enable you to run code at those key points. You could set values for the current record or you could create, update, or destroy other records. You could perform cleanup or housekeeping tasks. You might log information to a file or to the database. Or you might send an email or make an API call so that others know that a change was made. Ruby On Rails provides hooks where you can insert your custom code. It's up to you how you use them.

Use callbacks to automate actions

Now that we understand how callbacks work, in this movie we'll learn to write them in our code. This example shows a customer model with three callbacks. The first is a before validation callback to format a phone number. Phone numbers may be submitted in a variety of formats containing dashes, spaces, periods, and more. I imagine this callback is a method to standardize the format so that it can be more easily validated. The second callback is a before save callback to geocode the address. It might contact a third party service to get back a latitude and longitude to store the database at the same time as the record saves. The third is an after commit callback called notify admins. Anytime a record is created, updated, or destroyed, it will send a message to admins. Notice that it uses after commit and not after save. So it only takes place once the transaction is final. Each callback has the name of a private method is a symbol. We sometimes call this registering a callback. We register it at the top and define what it does further down. Let's try registering callbacks in our project. I've already added some methods to our task model. Let's take a look at a couple of them. I've got two here for titleize name which just takes the name and it titles it. I've got another one here for set default position. If the position is blank or less than one, then it will find the maximum task position using maximum. That's something we haven't seen yet but it finds the highest value in the column. If there is no value, it'll use zero, and it'll just set the position equal to max plus one. So let's come up here to the top and let's put a callback and let's put it right here after the validations. So right after we have our validations, let's do before validation. And the first one will be titleize name, and then I'm going to put a comma and let's do default position as the second one. There's no problem having a comma and having it run several in a row. They're both before validations. They don't have to be on separate lines. Now I've also got some down here to just demonstrate logging the create, logging update, and log save. This is before creation and before updating, this is after either one of those has been saved. So let's add some for that. So we've got before validation, let's add before create, and we're going to log the create. Before the update we will log the update. And after save, we will log the save. This should help you to see the difference between when they create and update callbacks are run. And then I've got one more down here at the very bottom called cleaning reminder that just logs a message saying to prune the old tasks. And so I'm going to do that after the commit. So after commit, after everything is completely done and we know that it 100% worked we're going to do a cleaning reminder. Let's try them out. We'll go to our console, rails console. On the validations we didn't actually save anything. We're going to actually have to save some records now. So let's do task equals task.new, name, and I'm going to do it all lowercase on purpose, rake leaves. And then I'll call task.save. Now it did save notice that we didn't give it a position. And we had a validation that should require the presence of the position and the presence should be greater than zero. But it passed the validation because we had a before validation that titleized the name and set the default position. Sure enough, if we look at task.name, you can see it titleized it. So it's capital R and capital L, task.position. It automatically gave it the next position, the next highest one. If we go up here and we look at our console log, you can see that it actually logged here task being created, that's before it happens, and then task was saved, it ran it here. Now let's try updating it, task.description and let's make it rake the leaves in the front and backyard. And then let's call task.save. So this time it does an update. You'll see it says task being updated, rake leaves, and then down here it's still task was saved. So that one ran both times in both cases. This one only ran because it was being updated. We can now add callbacks to our models. You write the code and then register it as a callback and Rails will run it at that point in the process.

Execute callbacks conditionally

In this movie, we will learn how to execute callbacks conditionally. Callbacks can be restricted to run only when a particular condition is met. And we do that by including the if or unless option and a condition that returns either true or false. 

The condition can be in a method that's in the model. In this example, the after_commit callback will call the send_welcome method if the country_emailable method returns true. It will skip it if it returns false. We can see that that method goes to the country model, uses a named scope to get the countries that are emailable, and then plucks their IDs to get an array that it compares against the objects country ID. Some concepts that we've been learning. 

We can also put the condition in a code block using a proc. Procs are similar to Lambda functions, but the small differences between them are not important here. You just need to notice how the method name has been replaced by code that says Proc.new and then has a code block. Inside that code block, there's a block variable declared which refers to the current object. You can't just type email.present like you can in an instance method because that assumes the current instance is the target. Here, we must use the block variable. 

Of course, if we can use methods, then attributes are just methods to access instance values so we can use any true/false attribute as a condition too. This example shows how we can suppress a callback by setting a non-database attribute. If skip_geocode has been set to true, then it will not execute the for save geocode callback. 

Let's try some examples. Let's start with our after commit for cleaning reminder. Let's only execute that if there's too many records. So I'm going to make if, and I'll make a new method here too_many_records, but we need to then put that as a method somewhere down here, so I'll scroll to the bottom and let's define it. What is too many records? Well, let's say that if the task count is greater than four, then we have too many records. Let's set another one by going up here and using a proc. Let's do this one on the set_default_position, before_validation, set_position, and I'm going to jump to a new line here and indent if Proc.new and then I'll use a code block and I'll use a t to represent the current task and I'm going to check to see if task.position is blank or t.position is less than one. If we go down here and check set_default_position, it already had that condition built into it, so we don't need that anymore. We now know how to conditionally execute it from a proc instead. Now, there's nothing wrong with doing it the other way. You certainly could, but this makes it clear that this is not going to run when these conditions are met. And for titleize_name, let's make a new attribute accessor. I'm going to do this all the way at the very top just so it's very obvious right at the start, accessor, and I'm going to call it skip_titleize_name. And if that's set, then we're going to skip that callback. So here it is here. I'll add unless skip, use a colon in front of it, skip_titleize_name. So now let's go in our console and try these out, rails console. Let's create a new task, Task.new, and let's give it a name, task.name, is going to be equal to and we'll call it Wash car. I'm intentionally lowercasing the c there, task.save. Now it did save it. If I do task.name, we see that it did titleize it. If we look at the logs, you see that it did remember to prune old tasks because we do have more than four of them now. We could set it to a different value if we wanted to try it and see if it works without it. Let's just try the task name again. Let's set it to lowercase c one more time, but this time, let's do task.skip_titleize_name=true, task.save. Now this time when we say task.name, you see it did not. It skipped that callback because we'd set that value. Whichever way you choose to write these conditions, it's useful to be able to set conditions on when your callback should run.

ACTIVERECORD ASSOCIATIONS

Overview of associations

In this chapter, we'll work with active record associations beginning with an overview. Associations keep our application's data well organized so that it can be used efficiently. Relational databases have three main association types one to one, one to many, and many to many. One to one associations relate one record to exactly one other record. An example would be one classroom that has one and only one teacher assigned to it. We would say a classroom has one teacher and a teacher belongs to a classroom. To make this work in the database, you'd put a column on the teacher's table to hold a foreign key, probably something like classroom ID. In a one to one association, which of these tables holds the foreign key is a design choice. They could be reversed. With that relationship established, if you have a classroom record and you want to find out what teacher belongs to it, you take its ID and search the teacher's table for a record with the matching foreign key. Or if you have a teacher and want to find the related classroom, you take the foreign key and search the classrooms table for a matching ID. One to many associations relate one record to many records. An example would be a teacher who teaches many courses. We would say a teacher has many courses and a course belongs to a teacher. In the database, we would need a foreign key on the courses table. To find all of a teacher's courses, we can use the teacher's ID to search the courses table for every matching foreign key. Or if we have a course and we want to find out what teacher belongs to it, we can use the foreign key to find the teacher's ID. You will use one to many associations much more often than any other type. Many to many associations relate many records to many other records. If we have four courses and four students who are enrolled in a mix of those courses, we would use a many to many relationship. We would say a course has many students and also belongs to many students and a student has many courses and also belongs to many courses. In this diagram, Chemistry is being taken by Michael, Jennifer, and Amy. Notice that we can't put a foreign key on the student's table like we did with one to many, because that's not the only course that each student is taking. Michael's taking Chemistry, Geometry, and Physics. We can't put the foreign key on the courses table because a course is being taken by several students, not just one. The solution is to use a join table that holds two foreign keys as a way to establish links between these two tables. In this diagram, those are the small boxes that link courses and students. If we want to find all students taking programming, then we search the first column of that join table and retrieve the student IDs from the second column. If we want to find all courses that a student is taking, then we search the second column of the join table and retrieve the course IDs from the first column. The first step to creating associations in Ruby on Rails is to provide the necessary columns in the database. We can add a foreign key column or create a join table at the same time as we create a model or we can add migrations to it later. Once the database relationships exist, then we can define the association in the models. Association methods define relationships between the models. They tell Rails to use the techniques that we discussed for finding the associated records. For one to one associations, we would use has_one in one of the models and belongs_to in the other. For one to many associations, we would use has_many and belongs_to. And for many to many associations, both models would use has_and_belongs_to_many. In this chapter, we will learn how to use one to many and many to many associations in our models. One to one associations are not that common and they function a lot like one to many associations. The main difference is that you're only allowed to associate one object instead of many. So we won't spend a lot of time on those and we'll focus on one to many instead.

Create a one-to-many association

In this movie, we will learn to define and use one-to-many associations. You will use them more often than any other type. When we define the association, one model will use the has_many method with the plural name of its association. The other model, we'll use the belongs_to method with the singular name of its association. And its table will hold the foreign key to establish the relationship in the database tables. By default, that foreign key will be the name of the associated class in lowercase with underscores and an ID at the end. You should always define both sides of the association. Each of these methods adds functionality to the model. For example, if this code did not have the belongs_to defined, then a teacher object could find its courses, but a course object would not be able to find its teacher. Our project already includes a one-to-many association. In the task model we use belongs_to category. In the category model, we have has_many tasks. This is a one-to-many association. Notice how the names are singular or plural based on whether we expect one or many associated objects. 

The associations and the models are only possible because we added the relationship in the database. 

We first created the tasks table without a foreign key. We later came back and added a column for category ID. Each task can only belong to one category and the category ID tells us which one. Notice also that it includes an index on the column. This index helps the database to look up the related records faster. You should always include them on your foreign keys. 

Once the database is in the correct state, then we can add those model relationships. Notice that the belongs_to includes optional true. The associated object in a belongs_to is not optional by default. One must be assigned. Rails does this by adding a validation for the object's presence, something like this:

 validates_presence_of :category

you don't see it, but if you use belongs_to, rails adds it for you, unless you set optional to true. 

This automatic validation was added in Ruby on Rails 5 so older projects won't have it. You need to consider whether there will always be an associated object or not. In this case, I've made the choice that a task can have no category at all. There's no right or wrong answer. It depends on how you will use it.

Use a one-to-many association

In this movie, we will use the methods added by the one-to-many associations from the previous movie. Now that we have our one-to-many association created, let's go into the console and let's see what methods have been added. Let's start by getting some objects to work with. Let's create a new category. Category.create, and I'll give it a name. I'll call it Monthly. And for task, let's see what tasks we have. I'll use Task.pluck with all of the IDs and all of the foreign keys and we'll get back an array and it'll show us what's associated with categories already. We can see that task one has a category and the other ones do not. So let's grab these next three to work with those. I'll have task1 will be equal to Task.find 2. And then we'll make task2 equal to ID four. And let's make task3 equal to ID six. Your IDs may be different than mine. Okay, now we have objects. Let's clear the screen so that we can see the methods that were added when we added the has many association to the category model. There are four that are the most important for managing the associated objects. We have category and it added a method for tasks. This will return an array of the associated objects. At the moment, there are no tasks attached to it. We can also set the associated objects to an array by using category.tasks and then the equals sign and then whatever array we want. So I'm going to set this equal to task1 and task2. You can see that it executed SQL and it set the category ID of those tasks to be this task. Notice that it happened right away. The third method it adds is we have the ability to append an object into the array. So if we take category.tasks, and we use the append operator, which is two less than signs, we can append task3 on and you'll see that it executed right away, if we scroll up here, a bit of SQL to set the category_id for that one too. Or we can remove an object from the array by using category.tasks.delete. Task3. And now we deleted the task that we just added. So those are the four main methods. Retrieving the array, setting the array, appending an object and removing an object. The first one actually returns a query that we can then chain other methods onto. So we can have category.tasks. We could use our named scopes for incomplete. And let's do where.not description is nil. And sorted. And it will execute that query and return those results to us. We can also use the query selectors that we learned. Let's go to category.tasks and do count. Or we can do empty. Any. Or one. Let's clear our screen again so we can look at the belongs to association. Let's start by using task3 and let's use reload on it to make sure that we have a fresh copy that has the data that's in the database. When we update objects like that in the console, they can sometimes get out of sync with what's in the database. There are two methods for managing the associated objects. The first is one that returns the associated object. So task3.category. It's nil right now but we can set it to a category using equals. And let's set equal to the category we have stored in the variable category. So it's set it equal to it but notice, it did not fire some SQL. It does have the value set in memory. So we can call task3.category.name and get back the right name but it's not in the database. We have to call task3.save in order to make that actually execute the SQL. There's one last thing that I want to show you. Let's say that we have task3 and let's set it equal to category nil. Now let's go to category.name and you'll see it comes back and says that it's undefined. The reason why is because the category is nil. So task3 is returning the category, which is nil, and then it's calling name on nil. And nil doesn't have a name method. This is a common problem that we run into where there's not an associated object and therefore, we can't call additional methods on it. One way that you can handle this is to use the ampersand in front of the period and that will only call the name method if category is not nil. So if category's nil, then it just returns nil. If it's something else, then it tries to call name on it. I think you'll find that that's useful. Now we know how to both define and use one-to-many relationship in Ruby on Rails. You'll use them a lot and you'll become familiar with them quickly.

Destroy dependent related records

In this movie, we'll learn to configure automatic destruction of records that are dependent on another record. 

Let's imagine that I have a project with a news article class and every news article can have many comments. With this code, if I delete a news article that has comments, the record for the news article will be deleted from the database but no edits will be made to the comment records. They'll still have a foreign key that points to a database record that doesn't exist anymore. It could be desirable to keep those comments around for some reason, but more likely we don't need them once the associated news article is gone. If we add an option for dependent destroy, then rails will add a callback to the model. After the news article is destroyed, each of the comments will be destroyed, too. 

We're telling it that not only are the comments associated with the record, they're dependent on its very existence. There are other choices for dependent records, too. 

The destroy option is the most common, but the delete_all option will also delete the associated records. But, instead of calling destroy on each object, it will destroy them all with one SQL statement. That's more efficient if there are a large number of records, but it also means that each associated object never has an opportunity to run its own callbacks. For that reason, I prefer to use destroy in most cases. 

The nullify option will keep the records but set their foreign keys to nil. This is a good choice if the associated objects should just forget about their former association. 

Let's consider whether deleting a task or a category should impact the associated records. Deleting a task shouldn't automatically delete a category, because other tasks may be using it. We almost never put this option on a belongs to. If we delete a category, we might want to delete all of the tasks that are associated with it, but in our case, we made the category optional. So, it's no big deal if a task continues to exist without having a category, however, we don't need to keep the foreign key assigned. So, we should use the nullify option. Dependent and nullify, but let's first demonstrate destroy, just so we can see how it works. I'm going to save this. Let's go into the rails console and let's create a new category. Category, create, and it can be any name we want because we're going to end up deleting it, but I'm going to call it "Low Priority." Okay. So, now we have our new category. Let's create a new task also that we don't mind being destroyed. Task equals task, create name, "Sort recycling." Okay. So, now let's add our task to the tasks using the append operator. Okay. Now, they're joined together. We ask task for its category ID. We can see that it's set to three. Now, let's destroy the category. Category, destroy. You can see that it deleted from tasks, as well as deleted from categories. If we call task.sorted.pluck, ID and name, and category ID, you get back of the list of the tasks. And you'll see that the task we created is no longer there. Now, let's go back and change it to nullify so we can see the difference there. So, instead of destroy, let's use nullify and let's call reload just so that we reload everything and I'll use the up arrow to create the category again. All right. So, now we have our category. Let's set a task equal to one of our existing tasks, and I'm going to choose one that does not have a category ID right now. So, that's "Rake leaves." That's ID-7. All right, let's add it to the task. I had the append that does that so category tasks will add in the tasks. Now, if we ask task for its category ID, it tells us that it's four. Now, let's call category destroy. We'll destroy our category and you'll see this time, it updated tasks and set the category ID to null. It did not delete it. It deleted the category, but it updated the task. And if we go back up here to where we take a look at them you can see again, "Rake leaves" has been set back to being nil. Configuring dependent associations prevents orphaned records and helps keep application data in good shape.

Has and belongs to many associations

In this movie, we'll begin learning the next type of association, Has and Belongs to Many. It's a long name. So you may see it abbreviated as HABTM. It's many to many relationship, And it's used when an object has many objects that belong to it, but they don't belong to it exclusively. For example, a project may have many collaborators but those collaborators are not exclusive to the project. They can collaborate on other projects too, or a blog post that has many categories, but the categories are not exclusive to it. Those categories can be assigned to other blog posts. 

A Has and Belongs to Many relationship requires a join table between two associated tables. It holds two foreign keys, and a best practice is to index those keys together. The join table does not require its own model. We will not be creating objects from it. It will just be used by the other models. It also does not need a primary key or timestamps. It just needs the two foreign keys. 

The join table name follows a standard convention. It's the name of the two tables being joined with an underscore between them. They should be an alphabetical order and plural. 

For example, a join table between a project and a collaborator would be called collaborators_projects. Notice that they're in alphabetical order. A join table between blog post and category would be blog_posts_categories. 

You don't have to remember this if you let Ruby on Rails help you. If you create a migration where the name includes the word "join table", and then the two table names, it will create a migration for the join table. The migration uses the create join table method with the names of the tables being joined. This creates a table with only two foreign keys. It also includes indexes for the foreign keys but they're commented out. In most cases, you want to uncomment those lines before you run the migration.

Once the database join table is created, you define the Has and Belongs to Many association in both of the models. 

This will install instance methods that are similar to the ones we used with Has Many. It's like having a Has Many, but on both sides. Active record will traverse the join table in the process. 

I've already generated a new model for the tag class. Just has one attribute for name and string. You can see over here that it's got the tag class. I've added a validation for it, but I haven't run that migration yet. And I also haven't written the migration from my join table. Let's do that together. 

Rails generate migration create, and then join table is the keyword that we need there to tell it that we're doing a join table. And then the two tables we're joining are tags and tasks. The idea is that we'll be able to apply tags to different tasks, but those tags won't belong to a task exclusively. They can be assigned to other tasks too. You created the migration. We come over here and take a look. You'll see it has create join table. And we want to uncomment these lines so it will index those foreign keys. Now let's come back over here and let's run our migrations. Rails DB migrate. So run two different migrations because I never ran the tags one. 

So now we have tags and we have our joint table tags and tasks. Once we have our database set, then we can go into our models and define the associations. So we have Has and Belongs to Many, and then we're going to use tags, and I'll copy that line and save it, go over here. And we'll paste it in. But instead of tags, it's going to be Has and Belongs to Many tasks. So they each get the same association pointing at the other one. Let's save it and let's try it out in the console. Rails console. And I'll just clear the screen. 

Let's start by creating a couple of tags. Tag1, tag create, and the name will be outdoors. And let's have tag2, and tag create. The name for this one will be indoors. And tag3, tag create, with the name of urgent. For the task let's just get the last task that we have in the database, task last:

  task = Task.last

Because we have the associations defined, we can ask for task.tags, and get back the tags that are associated there. Notice that it's going through tag tasks to find out the answer. We can also use task.tags equals, and assign an array of tags. 

Let's do tag1 and tag2. And you can see that it inserted into our join table the foreign keys that it needs to make that join. We can also use task tags and append tag3. So it'll add it on there. You see it also inserted a record for that, and let's do one with delete. Dot delete tag2. And you see it deleted from the join table. So setting up the join table and defining the associations is most of what it takes. After that, it's pretty much like working with your Has Many relationships. So task.tags.pluck name, outdoors and urgent. Tag3.tasks.pluck the name, and it tells us wash car. 

There are a number of user interfaces that your controller and viewers can use to manage Many to Many associations. I want to mention the collection check boxes helper method. It will output a list of check boxes so that the user can choose which objects to associate.

When migrating to Ruby 5 from an older version, оне should be careful of in regards to the belongs_to command and check that all belongs_to relationships are essential. As "belongs_to" relationships in Ruby 5 are essential by default and checked automatically, but you can make the relationship check optional.

Rich join associations

In this movie, we will learn about something I call Rich Join Associations. They associate two models in a mini to mini relationship, but they can hold other data and code in addition to the two foreign keys. If we have a mini to mini relationship between courses and students, we could use has and belongs to many, like we did in the last movie. The join table would be courses_students, and it would not need its own model. But what if we want to keep track of more information than just the relationship? We might want to keep track of the student's grade, the date they enrolled, or how many times they were absent. Such information should be stored in the join table because that's the record that maintains the presence of the student in the course. This is when it's better to use a Rich Join Association. We don't have to follow a table naming convention and we can name it something more descriptive, like course_enrollments. To access the additional data that it's going to carry, we'll need to give it a model too. Notice that course and student now use has many course enrollments. The course enrollment model has two belongs to associations, one for each of the foreign keys that it holds. It's the same concept, but with a different approach. The advantage of this approach is that course enrollment can have additional columns and define additional methods inside the model. It can be smarter than a simple join table. It still has the two indexed foreign keys, but it's more like a standard table with a primary key and a model so that we can query it directly and create instances from it. There are no table name conventions to follow, but I would suggest to you that names that end in -ments or -ships work well. For example, assignments, engagements, authorships, or memberships. I'm going to create a Rich Join Association between our task model and our user model. The idea is that a task has and belongs to many users and a user has and belongs to many tasks, but, in between the relationship, we're going to store additional information. We're going to store the role that the user is playing for that task. Perhaps they're supervising it or they're providing materials for it or they're executing the job or double checking it, whatever it might be. Let's create the join table that we'll need by going into our console and using rails generate, but instead of a migration, we're going to generate a model because we're going to have a model for this join. I'm going to call it task assignment, and for the columns that are in there, I'm going to use task colon references, that says to create a foreign key that's going to reference the task, and then I'll use user references, and then after that will be a simple column that's role string. Once we've generated that migration, let's come over here and take a look at it. You can see it uses the create table method. References is going to create that foreign key suitable for referencing the task and then one for referencing user, and then we've got a regular one for string, and some basic timestamps. Now, it doesn't know that I'm planning to use this as a join table, so it didn't give me indexes that go across the two foreign keys, so I'm going to add those myself. Index task id with user id and index for user id task id. Now that I have those, I'll come over here and I'll run our migration rails db migrate. Now our database has the join table that it needs. Now we're ready to go and define those relationships. So in task, instead of using has and belongs to many users, we're going to use has many task assignments, and I'll copy that, save it. Let's go over to user and let's add the same thing here because it also has many assignments, but in between task assignment belongs to task and belongs to user. And because I used references when I did the generation, it went ahead and added those for me very helpfully. Now this is not going to be optional true because we do want to make sure that both of them exist so that we can have a join. We don't want a broken join in between them. Once we've saved these associations, we can go over to our console, we can try them out. Let's start by just getting a task. I'll use task.first, and let's get a user, I'll use user.first. Now I can create a new task assignment. I'll do that ta equals task assignment and I will create a new one, and its task is going to be task. Now I could use task id equals task id, but I don't need to. I can just use task like that and it works the same, it knows to add the id onto it. And user will be user. Now it's created it. You can see from the SQL what it did, it added those foreign keys to it. Now I didn't have a role associated with it. Let's go ahead and add a role which is going to be the supervisor, ta save. Now, if I ask for task.task assignments, I get back the task assignments. If I ask for task.task assignments first.role, you can see the role of supervisor is there. I can also ask user for its task assignments or user task assignments first.task. It'll tell me the task that's on the other side there. As you can see, a rich join is a lot like a has and belongs to many association, but it allows a model in between that can hold additional attributes and methods. If the association will be simple, use has and belongs to many. If it has complexity, use a Rich Join Association.

Traverse a rich join association

In this movie, we will discuss how to traverse a rich join association. 

It's easy to traverse a has_and_belongs_to_many association. We start with one object, like task in this example, and then we ask for the association of related objects that are on the other side of the join table, such as the tags. Or we can traverse the association in the opposite direction. 

From a tag, we can get an array of tasks but the rich join we just created can no longer do that. We join tasks and users with the task assignments model in between. 

A task has a task assignments method that was installed when we used has many in the task model. It returns an array of objects that are in the join table. But a task does not have a method for users, the table on the other side of the join. It's only defined association is with task assignments. We've lost some of the functionality that we had with has and belongs to many. 

We could retrieve the task assignments and then retrieve the join user for each one but that's very inefficient. Instead, we can define a new association between the outer two tables that will find records through the join table. 

We do that with has many through. It allows us to reach across the join. It adds the same functionality that we had with has and belongs to many. You should create the association to the join table first and then add this association on top of it. 

In this example, you can see that both the task and user models have associations for has many task assignments. Then on the line right below, there's another association between task and user, but this one uses the through option with the name of the association to the join table. A task has many task assignments, and it also has many users if we go through task assignments to get there. 

Let's add this association to our project. Let's first see what the issue is by doing rails console and let's find a task, task = Task.find(1). And if we try task.task_assignments, we get back an array of records. But if we try task.users, there is no relationship to users, which is on the other side of that join table. 

So we're going to add that association by going here, where we have has many task assignments. Then we say has many users through task assignments. And I'm going to copy that line and save it 'cause then I'm going to jump over here to the user model and paste the same thing here, that it has many tasks if we go through task assignments. 

So there's two relationships. It has a relationship to the join table and it has a relationship across the join table to the objects that are on the other side. Now let's go back. Let's actually exit out of our console and come back in just to make sure that we start fresh. 

And we'll clear the screen, task = Task.find(1) and let's do task.users and you see it now tells me the user that's on the other side. Task.task_assignments.map and let's do TA, ta.user. That returns the same thing to me. But you can see that it's much more efficient to just call task.users than it is to write all of this out. We can also set user equal to user first and have user.tasks for return back the tasks for that user. And we can even do things like add user.tasks and then add in task.last, whatever that is to the set and it will add that task and it will create the task assignment that it needs in between. So now we have two has many relationships that we can use. We can find and work with the objects in the join table or we can find and work with the objects on the other side by traversing through the join table. Rails takes care of writing the appropriate SQL for both.

Join tables during queries

It is common to join tables when working with relational databases. Using our associations, we can join tables for our active record queries too. It happens automatically when we use the many-to-many associations but I want to show you two methods to assist you in joining other tables. 

Joining tables can become complex. So we'll stick to the simple and most frequently used cases. If we want to retrieve additional data from another table, along with our main results, we want to use includes. You provide it with an array of the associations to add to the query. In this example, the query will retrieve all of the tasks as well as the categories associated with them. If you know the categories will need to be retrieved too, it can be better to find both at once. 

Rails includes logic to choose the most efficient way to retrieve these records. It may decide to write SQL with the left outer join or it may choose to make several queries. You don't have to worry about which one it chooses. In the end, you'll get back data from both tables. 

You can add conditions to the query that reference either table. Notice how any conditions that are targeted at the categories table are listed in a nested hash after the name of the association. There's one catch. If you use a string or an array for the condition, or for another clause like order, then you must use references. This is important for helping Rails choose the best way to make the query. 

A condition with a hash will handle that for you but a string will not. Unlike includes, references wants an array containing names of tables, not names of associations. You'll notice here that categories is plural because the name of the table is plural, even though the association name is singular. 

Let's look at another method for joining associated tables. When we want to find records, which have records that exist in both tables, we use the joins method. It looks similar to includes but it can return different records. Includes returned every task record plus any categories. Joins returns only the tasks which also have categories. It does that using an SQL inner join. 

It can also add queries on both tables, and we don't need to use the references method because it's not trying to choose between query strategies. 

We won't go into detail on the differences between left outer join and inner join, just know that inner join only returns a result if there's at least one record in both tables. If you just want to add extra data from the join table if it exists, then includes is the better choice. 

Let's go into the Rails console and see how this works. So let's try tasks equals Task.all to start with. And then let's do tasks.map and for each task, let's get its category and if it exists, we'll get the name. Notice that when I did this, it made additional queries, right? Every time it looped through each one of these, it made another call to the database. Now let's try a version with includes. Tasks equals Task.includes category all. So this time, it went ahead and it preloaded the categories and it did that with two SQL queries. So you can see, this was more efficient. This one fired five queries total. This one just sent two. Now, this didn't actually use a left outer join. Let's try an example that'll trigger that. I'll hit the up arrow and let's change this so it's includes category and then where, let's do completed is false. And let's do the category is going to have an id that's in the range of 1 to 20. Now, this time, you can see that it joined tables into a single query because the condition that uses the categories will affect which tasks are retrieved. It can be a little slower than the simple preloading that we saw before but it's necessary to scope the query correctly. Don't forget that if you're using a string for the query, rails won't be alerted to the need to join the tables. So we'll have to do that. So let's change this to instead have a where clause that is categories.name LIKE and then we'll make it Week and close our braces. And you'll see we ran into a problem, right? It didn't work out for us. Instead, we need to come back up here and say references and then provide the table name categories. Now it knew to join it together. It knew that this was the right approach to take and it gave us results. Now let's try joins. So let's do tasks equals Task.joins category all. You can see that this time, it wrote an INNER JOIN in the SQL statement. We can see the difference between includes and joins if we count the results of each. Let's do Task.includes category and do count. And you see it comes back with six records and then let's go and let's just change this to joins, and you'll see it came back with four records. The first one using includes found all tasks and then added category data to them. Joins found all tasks which have category data. If a task didn't have category data, it got left out. Associations between models make it easy to join tables during queries so that your application can find the data that it needs efficiently.