https://github.com/LinkedInLearning/ruby-on-rails-models-and-associations-2488472
git switch 01_01b
rails lil:import

From the command line, navigate into the project directory, and run bundle install to install the RubyGems. Next, add the database credentials to the database YML file in the config directory and run rails db:create. You can run rails lil:import anytime you want to get the database data in the same state as mine.

SMARTER MODELS

Smart models by design

In this chapter, we will learn how to make our models smarter. We'll begin by considering how we determine what code should be put into a model. There's a common saying in the Ruby on Rails community, "Fat model, skinny controller." It means that it's usually better to move business logic out of the controllers and into your models. Your models become smarter, and that business logic can be called anywhere in your application without repeating yourself. All it requires is an instance of the model. We should consider what things an instance of the class should know about, or know how to do, and then define methods for them. Then those methods can make good use of the attributes and associations that are already inside the model. Here's a common and simple example. This controller finds a user and then sets a variable for the page title to the user's full name. You can imagine that the full name will be used often. Several of the view templates may also use it. If it will be used often and in the same way each time, shouldn't a user object know how to construct its own full name? It's very simple business logic but it illustrates the point. It would be better to move that logic to the user class. We can define a full name method that contains the logic to assemble it from the parts. Now, any instance can be asked for a full name. There's no need to repeat that simply process each time. The logic here has slightly better handling of a missing first or last name too. If we were to make more changes to the logic, it would be changed everywhere at once. The user object becomes smarter. Here's another example. An instance of the order class can be asked if it's recent or not. It knows what's considered recent, and it knows how to perform the calculation. Canceling order may be a multi-step process. A controller could perform those steps, but shouldn't an order know how to cancel itself? It can perform whatever housekeeping tasks or logging that it needs to do in the process. And then our controller becomes streamlined. The code is easy to read and the mechanics are taken care of behind the scenes. If more than one controller needs to cancel orders, we don't have to repeat ourselves and risk making mistake or having several versions that get out of sync over time. One hint that code may be better inside a model is when you find yourself passing model attributes around the controller. A model always has its attributes on hand. There's no need to pass them. 

In this example, a profit report finds a report in the database and then passes the start and end dates to methods which calculate the income and expenses. If a report already knows its start and end dates, it seems like the income expenses and profit or information the report object should know how to calculate and be able to tell us when asked, the controller is doing the model's work. 

If we were to move these calculations into the model that every report object becomes smarter. And we don't have to pass around the start and end dates anymore, the income and expenses methods can access those attributes easily. And the controller can be thin. It just finds the report. Given any report instance, any view template can ask it for the income, expenses, or profit. 

These examples show the benefits of moving business logic to models. We don't repeat ourselves which it produces the amount of code and organizes it well. Dry code is easier to maintain and reduces the chance for bugs and inconsistencies. The business logic in model methods can be called throughout the application. It's also handy that it's easier to work with in the rails console, and easier to write code to test the logic to make sure that everything is working is expected, but that the same time, don't get carried away. Code for decisions about how to respond to user actions still belong in a controller and code for presenting data still belongs in the views. If you have complex formatting logic you should put it in view helpers. If you find that you're putting HTML, CSS, XML, JSON, or JavaScript into your models, it's a sign that you may have moved too much. Those are for formatting data and responding to user requests. 

The exercise files include a Ruby on Rails application which is based on the project we created in Ruby on Rails essential training and worked on in Ruby on Rails controllers and views. Let's add a user model, and we'll give it columns for the first name, last name, and email. Generate model, user, first name, string, last name, string, and email string. We see that it created a new migration for us here, and we can run our migration with rails db migrate. And we see that we also have a model here for user. So let's go into the user model and let's add a couple of methods. Let's go ahead and add that full name method, and we can do it the same way that I did it on the slide. First name, last name, and we will join them together with a space. Let's also copy that, and let's make another version of it which we will call, "last name first." It's the same thing, but we will just take the last name and put the first name after it. Still, instead of a space, let's join it with a comma. So it's comma space. And then let's add one more version here. I'll copy this. And I'm going to call this one, abbrev name for abbreviated name, and we'll find the first initial for the person by taking the first name characters first, and we'll add to it a period space, and then we'll take the first initial and put it here as well. So now we have three methods. We've made our user model smarter because it can put together the data and construct it in different ways. So let's save it and let's go over here and try it in the rails console. One of the handy things about making models smarter is that we can try things here. We don't have a user yet since we just created one, so let's create a user. user = User.create(first_name: '', last_name: '', email: '') and you can can give it any name you want. I'm going to call mine Kevin and last name Skoglund. And for the email, I'll put in someone@somewhere.com. Now, I created the user so now we can do user full name, user last name first, and user abbrev name. Now, these are just very simple examples. Obviously in your application, you're going to put a lot more complex logic here. But even these simple methods make the point that it's better to move business logic out of your controllers and into your models.

More ActiveRecord query methods

In this movie, we will learn more ActiveRecord query methods so that we can find records more efficiently. In the Ruby on Rails Essential Training, we learned a query for records using where. It can accept a string, an array, or a hash. I like to use a hash when I can. when the hash has several elements, Rails will join them into an SQL query using AND. We can also daisy chain several where clauses together, and Rails will also join them, using AND. That's especially useful when one of the queries uses a hash, and the other uses something else. In this example, the second query uses an array 'cause it includes a greater than in the where clause. Chaining clauses is possible because Ruby on Rails does not fire off the database query right away. It waits until it's needed. This example chains two queries, and assigns the query to the variable products, but it still does not execute the query. Further down in the code, if either of two conditions are met, it will chain on additional where clauses. Each time it calls the where method on the existing variable, and assigns the result to the same variable name. This is a common and useful pattern. You can also write an AND clause using the AND method. It is a little more cumbersome. It takes a query as an argument, which is why you see the product class being used twice. It must use the same model, and it should only have a where clause. This is most useful when you already have one query defined for another purpose, and then you want to incorporate it into another query. All three of these examples would execute the same SQL. It's useful to see how that AND method works, because that's how the OR method works too. You can't write an OR clause without using the OR method. Personally, I find this second form to be more readable. Remember it's not actually making two queries. The first query is defined, but not executed unless it's needed. When we use an AND clause, we are narrowing the possible results. When we use an OR clause, we are expanding the possible results. Ruby on Rails also has a NOT method that can be added to a where clause. It negates the contents of the clause. You can see how the SQL adds NOT right after AND. Of course, you could reverse the contents of the query instead, but sometimes this will be more readable in your code. Let's test drive them. Even without a lot of records in our database, we can still go into the Rails console and see the SQL that's generated by the queries. We have a task model, we do task dot all. You can see them all in there. And if we scroll to the top, you can see the SQL that it generates. If we do task where completed false, we'll get a where clause added. 

Now, we actually are seeing the results in executing it, but we also could put two underscore SQL at the end, and that will not execute the query, but just show us what the SQL would be. That can be helpful. So let's try another version, where we just come up here and add into it that the category ID should be one. And you can see the SQL that it generated, and you can see that it added an and there. We can also try assembling two together. Let's do tasks equals task dot where completed is false, and where created at is greater than something, and that will be one month ago. And I'll hit return. Now the console fired that request immediately because we're in the console. It went ahead and executed it because it assumed it was needed. If we were in our application code, it would not have fired that request yet. It would wait until it was actually needed for some other purpose. It's a kind of a quirk of working in the console. We can go ahead and add onto that, using tasks equal tasks dot where, category ID is one. You see here that I'm using tasks and tasks twice. I'm just calling where on it, and assigning it to the same variable name. And you can see that it assembled it with and, an and. Let's try using the AND method. I'm going to make something called undone, which is task dot where completed is false. Let's imagine that I have this for some other purpose in my application. And then I could have something else that says task where category ID is one and undone. So I'm passing in that scope from above, and it will combine them together. Select task where category ID is one and completed is false. And that same thing works with OR, category ID one or undone. If we scroll up here a little bit, you can see that it adds in category ID one or task completed is false. And then let's just try one that's a NOT. Let's try task dot where not category ID one, so all the other categories besides this one. Using these query methods will make it easier for application code to find records efficiently.

To display your results in a way that can be paginated use the offset keyword. This keyword is used to start the results at a different position other than the first record. This can be used to code for pagination.

Select data from a query

In this movie, we will learn how to refine a query so that we retrieve the data our application needs as efficiently as possible. The simplest selections are all, first, and last. It's usually not necessary to use all at the end of a query because it's implied, but all is useful when there is no other query method or when we want to cause the query to execute right away. It will return an array. The first method will limit the query to one record and then return an object instead of an array. The last method does the same thing but reverses the sort order so that what was the last record becomes the first. These methods return instances of models, either a single object or an array of them. For each row, return from the database by the query. Active record will create a new instance of the object and populate it with the values of that row. As developers, we need to be mindful of the workload that requires. It's insignificant when there are 20 records but it's substantial when there are 20,000. Notice the difference between these queries. The first query is retrieving every customer record, even if there are 20,000, and it spends time populating values for Ruby objects for each one and holding them in memory. But the next line is only using the first five objects. The others were wasted effort. The second query returns only the five records we want and it only dedicates time and memory to those five objects. It can be much faster. The first and last methods can also accept an argument for the same result. The same is true if we don't actually need the records at all. We can use count to get back only the number of matching records. This is much faster than retrieving all records and measuring the length of the array. Rails also provides any and none which will test for returned row without creating any objects, and many and one that use a variation of the count to tell you if there's one record or more than one record Rails is also smart about using the results of previous queries to find these values if they're already available. There are also several methods for returning partial data from a matching row. A query typically selects all columns from a table but the select method limits the SQL to the columns listed as arguments. This example is selecting only the ID and name columns. This will retrieve less data when there are many columns in the table. It still creates an instance of the class using those values, but any of the other attributes will not be available. This may be useful for some cases, but more often it's better to work with objects that have all of their attributes. For selected values, the pluck method is usually a better choice than select. The SQL is the same. It also selects only the listed attributes but it returns an array of the values, not objects. The result is similar to querying for many objects and calling map on the collection, but it's much more efficient if those are the only values that we need. The IDs method is a shorthand for plucking the ID from each row and returning them as an array. If you just need the IDs, it's much more efficient than retrieving all objects and then making an array out of them. Let's try these out. Let's go into our Rails console and let's just try our task model and we'll call all on it. And we already know that that's going to give us back all of the records that are there, right? It's going to find everything and it's going to instantiate Ruby objects for each one using the values from those rows. Task dot first. You can see the SQL it generates. It just finds one record. Only one. It doesn't create a full array. It just finds one and gives us back just that object, not an array of objects. And task last does the same thing but it reverses the order before it gives it back to us. So let's try setting tasks equal to task all. We're going to get back all of the objects that are there. We know how many are there because we can put task count on it. There are four. So let's find less than that. Let's do tasks zero to two, right? So that's just going to gimme back three objects. So now I've created a fourth object that I never used. Let's try instead to do tasks by task, limit three. Now it's only finding the three objects that I need to begin with. That fourth object, it didn't create and then discard. And we can do the same thing if we do first three. It does the same thing as if we do limit three. Let's try another one where we do task dot where completed is false. Let's see how many of those there are. We have three of them. We can also use any. We know there are some, so it says, yes, there are. If I say none, I'm asking it, are there none? It comes back and says false, there are none. Notice here in each case, it's selecting one as one from the tasks and it's doing limit one also. It's just asking for one record. So one record, just tell me if it's there or not. And then we have the variations. We have many and one. These are essentially asking for the count to find out whether there's one record or many record. Let's try with select. Let's create a task with task dot select ID and name and completed. And we'll just do the first for it so we just get back one. Now, if we do task dot name, the name is there. But if we do task dot description, it's not there. We get a missing attribute error. It's like we have a half functional object. Sometimes that might work for you. But most of the time I think it's better to use task dot pluck and ask it to return back whatever it is you want. So name and completed, let's say. It will give you back an array of just those values. It doesn't try to create objects at all. It's just data. And we could also do task dot IDs if we just want to get back an array of IDs. So select the ID from tasks and it just makes an array of the result. These selection methods allow more efficient queries which can make your application faster.

Named scopes

In this movie, we will learn how to use named scopes in our models. When we discussed model design at the beginning of this chapter, we saw the benefits of moving commonly used logic into the models. Named scopes follow that principle. And they allow us to define commonly used queries in our models. You construct them out of the built-in query methods that we've been using, but they're stored as lambda functions, which create a block of code for later use. You won't use lambda functions often, but named scopes require them, and they're easy to learn. In this example, the Product class has a named scope. It uses the keyword scope, followed by a symbol for the name that we want to give it. And then there's a comma and an arrow created from a minus and a greater than sign. That arrow indicates that the block inside the curly braces is a lambda function. It holds code to be used later. We can use our named scope by calling it on a model, just as if it were a built-in query method. We've just wrapped it up and given it a name. We can chain named scopes together, just like we can other queries. The code is compact and very readable. Plus we don't repeat ourselves, which is better for maintaining bug free code. 

Named scopes can also accept arguments. You can define the block variable inside the curly braces, as you would any other code block, but to do that, you have to use the word lambda. If you use the lambda syntax with the arrow, the block variable goes outside the curly braces. 

The search scope here contains Ruby code in addition to the query. You can include as much Ruby code as you like, as long as the block returns an active relation query at the end. That ensures that another query can be chained onto it. Notice how the complexity of searching gets packaged up and hidden. 

In our controllers, we can just pass in a string to the scope, and the model holds all the logic that makes it work. 

Let's add some scopes to our project. For the User class, let's add a scope. I'll just put in the keyword scope. I'm going to give it the name of sorted, then a comma, then I'll use the lambda arrow, and then in curly braces, I'll put the code that I want to execute at a later time, order, and we'll make it last_name, first_name. So now I can call sorted as a query, and it'll just depend on this order clause. I'm going to copy that, and let's make a variation of that in our category. I'd like to put the scopes for sorted in most of my models, that tells me how I want to sort them by default. And this one, we'll just sort by name by default. And then let's go into task and we can add one here as well. This time, the task is going to sort by position. It has a position. So that's going to be its sort order. Let's add a few more to it. Let's add scope for task for when it's complete. And that will be the where clause for completed is true. And I'll copy that and paste in another one. I'll put in in for incomplete, where completed is false. And we have sorted, and let's add one for search, just so we can see what it looks like with search. If we're going to use the arrow, then we have to put the variable that we want to use here. So that's the block variable to use inside here, where, and let's do LOWER name is LIKE ?, and what we'll drop in there will be percent as wild cards, and then we'll drop in the string kw.downcase. Now, we could do more processing in here, but I'm going to keep it simple. Now let's save all of this and let's go over here and try it in our console, rails console. And we can have User.sorted. And you see it went ahead and just appended that ORDER clause on there. We can do Category.sorted. 

We can do Task.incomplete.sorted, and search for laundry, and it returned back the Task force. You can see the SQL that it assembled. And we got back this object because laundry is included in the name. Named scopes are powerful way to make common queries convenient.

The stabby Lambda syntax uses a hyphen followed by a greater than sign "->" in place of the word "Lambda" for shorthand.

Non-database attributes

In this movie, we will discuss the utility of non-database attributes in Ruby on Rails. In basic Ruby, we can create new instance of attributes with several methods, attr_reader, attr_writer, and attr_accessor. 

This example uses an attr_accessor for status. That line has the same effect as if we had defined both a reader and a writer method for status as you see written out below it. An attr_reader would have the same effect as the status method. An attr_writer would have the same effect as the status equals method. 

We can also use these types of custom attributes in our Rails models. After all, attributes are just methods to access values. They don't have to be values stored in the database. They can be preserved in memory. We can communicate information to an object and set a temporary state inside of it. We don't need to store that information long term in the database, but it can affect the values and behaviors of other methods. 

Let me give you an example. 

This Payment class has a database table associated with it. Rails will automatically provide attr_accessor methods for each of its columns. In addition, this class has an attr_writer method for card_number and an attr_reader method for transaction_error. These attributes do not have a database column to go with them. 

Further down, the code instantiates a new instance using payment parameters which is likely derived from a submitted form. Let's assume that the form had a field for card_number. Ruby on Rails will assign the form value to the attribute for card_number. It doesn't care whether the attribute uses database storage or not, and it's a good idea not to store a credit card number in the database. 

When the next line calls the process method, it uses the instance variable for card_number to charge the credit card and then sets any error in the return result to transaction_error. The code can then extract any transaction error, because we have an interface that lets us read it. 

You can see how these values are transient. They just exist as a temporary state inside the object. When the object is done, they disappear. 

Here's another example where payment has an attr_accessor for zone. When the request domain matches a European domain, it will use a European payment processor. If not, it uses an American payment processor. 

The zone attribute establishes a context or a mode for the object that affects its behaviors. You won't use them every day, but defining non-database attributes is a valuable technique to have in your toolbox. They can also be useful with validations and callbacks which we'll examine in the upcoming chapters.

DATA VALIDATIONS

Overview of validation methods

In this chapter, we will learn about validations, starting with an overview. Validations allow us to make sure that data meets a set of requirements before it is saved to the database. You can think of them as rules that our data must follow. We define these rules in our models. As we discussed in the last chapter, a model should know whether data is good or not, and it is best positioned to be the gatekeeper to the database. If data doesn't follow the rules, it will fail the validations and the record will not save. It will keep track of the errors, which is useful so the user can see what went wrong and try again. Rails includes many validation methods. They allow us to ensure that data exists and has the correct data type, value, or format. Here's an example of a validation inside a product class. Each one has the validation method with the attribute to be validated plus any options that it requires. Let's learn how each validation method works. The most common validation is validates_presence_of. It ensures that an attribute is not blank. It can't be nil, false, an empty string, a string of only spaces, an empty array or an empty hash. If we add a line to validate the name attribute and then try to save a record without a value for name, it won't be saved and an error message will be recorded. The validates_length_of validation ensures that an attribute has a certain number of characters. If we validate that the name is within the range from three to 40, then anything less than three or more than 40 will be rejected. It accepts options for is, minimum, maximum, and within. The validates_numerical_of method ensures that an attribute is a number, either an integer or a float. The options can specify equal to, greater than, less than, greater than or equal to, or less than or equal to. The validates_inclusion_of method ensures that an attribute is in a list of choices. To do that we need to provide it an array or range using in or within. In this example, status must be one of the strings that's included in the array. The opposite behavior is in the validates_exclusion_of method. In the example, zone ID cannot be either 78 or 109. The validates_format_of method ensures that an attribute matches a regular expression. This is handy for things like email addresses, URLs, phone numbers, and zip codes. The with option is used before the regular expression. This example validates that the zip code is five digits. The validates_uniqueness_of method ensures that an attribute is not already in the database. In this example, it ensures that every username will be unique. Now to confirm this, the validation must make a call to the database. The options can set case sensitive to true or false or provide a scope for the unique requirement. For example, you might scope this example validation by company ID, which would allow duplicate usernames as long as they aren't from the same company. The validates acceptance of method ensures that an attribute has been set. Its main use is to test if a checkbox on a form was checked. It will store the value if you have a column in the database, but if not, it will create a non database attribute that has no table column. So for example, you might have validates_acceptance_of some terms of service. You can also use the accept option to change what value it expects to receive, which is one by default. The validates_confirmation_of method ensures that an attribute has been confirmed by submitting it twice. You've probably done this for passwords or email addresses. You enter it once and then you enter it again. It creates a non database attribute so that it can receive the duplicate confirmation value without needing a column in the database. It also only validates when that value is not nil. That means that if you don't include a form input for it then it won't run this validation. A customer facing page might require confirming their password while an admin facing page might not. The validates_associated method ensures that the associated objects are also valid. We'll talk more about associations in a later chapter. But this method says before one object can be considered valid, we must check all the associated objects too. The first argument is the association name, not an attribute. It will call the valid method on any of the associated objects. However, it does not fail if the object does not exist, only if it exists and is not valid. You may want to parrot with validates_presence_of if the object must also exist. Be careful not to create infinite loops or long cascades. If one object requires an associated object to be valid, the associated object should not require the other object to be valid, or they'll keep asking each other in circles. Most validation methods accept a few standard options. You can pass in allow nil or allow blank. You can specify that the validation should run anytime a record is saved, only when a new record is created, or only when an existing record is updated. You can use if and unless to set conditions for the validation. The default error messages are pretty good but you can also customize them by setting the message option. In the next movie we'll try using these in our project.

Write validations

Now that we have an overview of validations, we will add some to our project, but first, let's consider what data should be validated. Deciding what to validate requires asking what your data concerns are. The concerns will be different for each project and for each model. A good starting point is to consider what good and bad data look like. Consider what restrictions your database imposes. A model should block data that the database won't accept before it tries sending it. Ask yourself what data would stop your application from working correctly. Your code may include assumptions about data being present in a certain format or with a certain value. It may take a little while to get a feel for it, but you can start simple and add more validations over time. Typically you won't need to validate low level data like IDs, foreign keys, timestamps, or boolean. Those are simple enough that they don't require it. Let's add validations to the user model. What should we validate? A user should probably always have a first name and a last name. In fact, you'll notice that the brev name method that we created earlier would run into an error here if the first name is blank. We could change the code or we can use a validation to ensure that a value exists. Let's do that by adding a line up here validates the presence of first name. I'm also going to add another validation to validate the length. Validates length of first name, and we're going to provide it with an option here, and I'm going to use minimum of one. Now, I picked one specifically so that I can show you the difference between validating the presence and validating the length. Let's save it and let's go into the rails console and try it out. So let's start by creating a new user, and let's just try to save that user to the database. It returned false. It prevented saving it because of our validation. And we can see the problem. If we use user.errors, and we'll get back an array of the errors. Now, it's not a very friendly format, but you get the idea that the first name was blank, and the first name was too short. More user friendly errors that we might show to users, we can get with user.errors.full_messages. And now you can really see first name can't be blank. First name is too short. Minimum is one character. You can see that the two messages are different. Notice that it ran both validations. It runs all of them and reports all errors. It doesn't find the first error and stop. It would be annoying if there were several errors and a user had to submit a form several times in order to find and fix them all. Let's try adding a first name now. User.first_name, and I'm just going to use test. Now, I'm not going to save it. Instead I'm going to use user.valid? to find out if it would save. That's the same method that save calls to find out if it's okay to save it or not. So user.valid return true. So this object is saveable to the database. It passes the validations. Let's try another example. User.first_name equals, and I'm just going to put five spaces inside the quotes. Now let's ask whether user is valid. This time it's not. Why not? Let's go up and let's check the full messages. The first name can't be blank. It passed the length validation but not the presence validation because an empty string is considered blank or not present. Let's exit the console and go back to our code. Now, I'm also going to add a validation here for validates the presence of last name as well. You can leave the linked one or you can change it to something else if you want. I've also gone ahead and added some validations here as examples for task to validate the presence of the name, the length of the name with the maximum, the presence of the position, and the numericality of the position should be greater than zero. For category, I've added one to validate the length, and it's within two and 50. You can try these out on your own. I want to mention that our project already has code to display errors on the category and task. If we go into our views on the task form, you can see we're calling error messages for, that's actually a helper method that we define here in application helper which renders a partial layout's error messages. And if we go look at that, you can see that it is outputting the errors. The most important part is right here. Object.errors.full_messages just like we were doing. We're going to output the errors so we can call this helper method any time we want to display the errors on an object. Now we know how to write validations and how to display errors to the user. Good validations will improve the quality and consistency of the data in your application.

Use the multipurpose validates method

We've learned the basic validations. In this movie I want to show you a different way to write them that can sometimes be more convenient. This user class has five validations all on the email attribute. It validates the presence, the length, the uniqueness, the format, and the confirmation. These same five validations on email can be written as one line behind the scenes. Rails sets up the five validations that we saw in the previous example. This version is just a concise way to write them. It's less typing and you may find it easier to read. I indented them to show them clearly but that's not necessary. It begins with a new method called validates and then the attribute and then a hash. The keys of the hash are the validations that should be applied. And the values are either options for the validation like the options on length in this example or simply the value true. Here, we see the validates method with all of the validations that we've learned. It can have presence, numericality, length, format, inclusion, exclusion, acceptance, uniqueness, and confirmation. You can see that length, format, inclusion, and exclusion expect options. The other validations, the one where the value is true, those will also accept a hash which is where you would put other options like customizing the error message that it uses. Let's try them in our project. I've already added these to the exercise files so that you don't have to watch me type them all. I've included a constant that's just a basic regular expression that'll check whether something matches a typical email address. Notice that instead of having the validates presence of, I now have validates first name, presence true. That'll do the same thing. And instead of having a separate line for validates the first name's length, I can now just include it as another option, length, maximum 25. I've done the same thing for last name. Presence true with a length that's maximum 50. And then for the email, we'll make sure that it's present, that its length is not over 100, that it is a unique value, that it matches the format of the regular expression, and that the confirmation is true if it's sent in. Now, you can still mix and match these with the other style of writing validations. You can see I added one down here that's validates acceptance of terms. In this case I think it's easier to write it this way than it is to use the validates method. Let's test drive them. 

Let's go into the rails console and now let's try and create a user with user.new. We can check user.valid. It comes back and says it's not. User.errors.full_messages. And you see that it comes back and tells me all of these. It runs the exact same validations that it had before. Let's try user email equals nothing and then let's try user valid. And then if we go up and check the error messages, you'll see that this time it's not that the email can't be blank but it's still an invalid email. That's the message returned. We also get to see that it actually went and checked the database to see whether it was a unique email or not. So it made this SQL query here to find out whether the user with email nothing was existing in the database. We now know two ways to write validations. They work the same, which one you choose is a matter of the context and your personal style.

Creating an input value of four whitespaces and applying the rules validates_presence_of and validates_length_of with a minimum length of four as a test, makes results 

  validates_presence_of is false, and validates_length_of is true

The first rule returns false because whitespace is considered blank. (The validation rule "validates_presence_of" makes sure that a value is supplied and is not blank.) The input has a length of four characters, so the second rule is true.  

Write custom validations

The built-in validations are powerful and cover most of your needs, but sometimes there are special cases that require writing custom validations. We can do that with the validate method. Notice that it is singular, not plural like the validates method we used in the last movie. After that, we provide a symbol, which is the name of the custom validation method we want to run. Like the other validations we learned, the custom validation can use options to run it for every save or just for create an update actions. Inside that custom method, you can put any code you want, but it usually has two features. It includes some kind of test case that will be true or false. And if it's true, the method will add an error to the object's errors array. This is how the built in validations work, too. They run test cases and add errors if the test fails. When the validation process ends, having any errors indicates the object is not valid. We add errors with the add method, the attribute we want to add it to, and the message to show the user about the nature of the error. The custom method could perform several tests and add several errors, but I recommend making them separate whenever possible. Let's try an example. Let's write a validation on our task model and I'll put it right here. Let's validate singular that the description has no prohibited words. It's a long name, so I'm going to copy it. I'm going to drop down here. I'm going to make a private method for the same thing. I make it private because nothing else really needs to call it except this class. So descriptions has no prohibited words. Now we may not have a description. A description is not required. There's no validation for it. We made it optional. So I'm going to add a line that says return unless the description is present. And then I'm going to make a list of the prohibited words. "Prohibited words". And the prohibited words I'm going to use are procrastination words. This is a to-do list, task manager. So I'm going to prohibit using anything that might suggest that I'm going to procrastinate. You can make it anything you like. And then we'll take those prohibited words and we'll iterate through them for each one. And inside, let's check to see if the description includes it. We'll do that with if description.include and then word. And what do we want to do if it does include it? We want to add an error onto the error's array with add. We're going to add it for the description so it is attached to the problem attribute and then comma and then a fragment sentence that starts with the description. So the description cannot contain prohibited word and because I'm using double quotes there, I can interpolate a value and I'm actually going to input the word so that we can actually see what the word is in the error message so that we know what the problem was. Otherwise, it might be a bit of a mystery where we used some words prohibited, but we don't know which word it was. So let's put that in there. Now let's save it and let's go try it out. We'll go into our terminal. We'll run the rails console. And let's start by creating a new task. Task.new, and we'll give it a name. I'll just make it test. And we'll go ahead and give it a position of 10. But I won't give it a description yet. Let's check and see. Task.valid. Yes, it is valid. Let's try adding a description. Task.description and let's just make our description test. Is that still valid? Yes, it is. Now let's try and make it test later. And when I check, it's false. It's not valid. And if I call task.errors.full messages you'll see, "Description cannot contain prohibited word later." Notice how it assembled the name of the attribute with that fragment that we provided, too. It's easy to create custom validations by using the validate method to add errors to the object if a test case fails.

ACTIVERECORD CALLBACKS

Overview of callbacks

In this chapter, we will learn about callbacks, beginning with an overview of how they operate. Callbacks allow us to intervene in an object's life cycle. It's as if the standard code pauses at key moments to check in with you to see if there's custom code that you'd like it to run before the process continues. Callbacks will run code automatically before or after an object is created, updated, or destroyed. This chart helps explain how they work. There are three columns for creating, updating, and destroying an object. If you read down each column, you will see where we can intervene. Let's start by looking at the first column for create. Our first opportunity to intervene is before the object is validated. Validation happens before every creator update action. If we use a before_validation callback, it will run our code and then proceed to the validation. For example, our code could add default values to help an object pass its validation. We get another intervention point right after the validation. The most useful and common validations are the ones before and after the database interaction, where it either creates, updates, or destroys a record in the database. Create has two callbacks, before_save and before_create. If you look over at the center column, you'll see why there are two. If you write a before_save callback, that code will run when the object is created or when it's updated. If you write a before_create callback, it will only apply to object creation. The database interaction takes place after those two callbacks. And then we get two more, after_create and after_save, and they follow the same logic as before_save and before_create. One applies to any save and the other is just to an object's creation. And then there's a third callback, after_commit, which is somewhat new but useful. Ruby On Rails wraps the database interaction in a transaction. If anything goes wrong with the changes that it sends to the database, it can undo those changes. That's useful if changing one record in the database is triggering other changes to other records at the same time. The changes are a set and changes in the set are not completely committed to the database until all of the changes are complete. Some changes could still be rolled back. The after_create and after_save callbacks take place inside the transaction, after the change to one object has succeeded but before we're sure that everything is finalized. The after_commit callback is the point where the changes are completely done. As an example, if we wanted to send an email after an object is created, we should do it in an after_commit to be certain that the save was successful. The column of update callbacks is similar to the create column. The column for destroy callbacks is simpler. Notice that it also executes any after_commit callback. These callbacks enable you to run code at those key points. You could set values for the current record or you could create, update, or destroy other records. You could perform cleanup or housekeeping tasks. You might log information to a file or to the database. Or you might send an email or make an API call so that others know that a change was made. Ruby On Rails provides hooks where you can insert your custom code. It's up to you how you use them.

Use callbacks to automate actions

Now that we understand how callbacks work, in this movie we'll learn to write them in our code. This example shows a customer model with three callbacks. The first is a before validation callback to format a phone number. Phone numbers may be submitted in a variety of formats containing dashes, spaces, periods, and more. I imagine this callback is a method to standardize the format so that it can be more easily validated. The second callback is a before save callback to geocode the address. It might contact a third party service to get back a latitude and longitude to store the database at the same time as the record saves. The third is an after commit callback called notify admins. Anytime a record is created, updated, or destroyed, it will send a message to admins. Notice that it uses after commit and not after save. So it only takes place once the transaction is final. Each callback has the name of a private method is a symbol. We sometimes call this registering a callback. We register it at the top and define what it does further down. Let's try registering callbacks in our project. I've already added some methods to our task model. Let's take a look at a couple of them. I've got two here for titleize name which just takes the name and it titles it. I've got another one here for set default position. If the position is blank or less than one, then it will find the maximum task position using maximum. That's something we haven't seen yet but it finds the highest value in the column. If there is no value, it'll use zero, and it'll just set the position equal to max plus one. So let's come up here to the top and let's put a callback and let's put it right here after the validations. So right after we have our validations, let's do before validation. And the first one will be titleize name, and then I'm going to put a comma and let's do default position as the second one. There's no problem having a comma and having it run several in a row. They're both before validations. They don't have to be on separate lines. Now I've also got some down here to just demonstrate logging the create, logging update, and log save. This is before creation and before updating, this is after either one of those has been saved. So let's add some for that. So we've got before validation, let's add before create, and we're going to log the create. Before the update we will log the update. And after save, we will log the save. This should help you to see the difference between when they create and update callbacks are run. And then I've got one more down here at the very bottom called cleaning reminder that just logs a message saying to prune the old tasks. And so I'm going to do that after the commit. So after commit, after everything is completely done and we know that it 100% worked we're going to do a cleaning reminder. Let's try them out. We'll go to our console, rails console. On the validations we didn't actually save anything. We're going to actually have to save some records now. So let's do task equals task.new, name, and I'm going to do it all lowercase on purpose, rake leaves. And then I'll call task.save. Now it did save notice that we didn't give it a position. And we had a validation that should require the presence of the position and the presence should be greater than zero. But it passed the validation because we had a before validation that titleized the name and set the default position. Sure enough, if we look at task.name, you can see it titleized it. So it's capital R and capital L, task.position. It automatically gave it the next position, the next highest one. If we go up here and we look at our console log, you can see that it actually logged here task being created, that's before it happens, and then task was saved, it ran it here. Now let's try updating it, task.description and let's make it rake the leaves in the front and backyard. And then let's call task.save. So this time it does an update. You'll see it says task being updated, rake leaves, and then down here it's still task was saved. So that one ran both times in both cases. This one only ran because it was being updated. We can now add callbacks to our models. You write the code and then register it as a callback and Rails will run it at that point in the process.

Execute callbacks conditionally

In this movie, we will learn how to execute callbacks conditionally. Callbacks can be restricted to run only when a particular condition is met. And we do that by including the if or unless option and a condition that returns either true or false. 

The condition can be in a method that's in the model. In this example, the after_commit callback will call the send_welcome method if the country_emailable method returns true. It will skip it if it returns false. We can see that that method goes to the country model, uses a named scope to get the countries that are emailable, and then plucks their IDs to get an array that it compares against the objects country ID. Some concepts that we've been learning. 

We can also put the condition in a code block using a proc. Procs are similar to Lambda functions, but the small differences between them are not important here. You just need to notice how the method name has been replaced by code that says Proc.new and then has a code block. Inside that code block, there's a block variable declared which refers to the current object. You can't just type email.present like you can in an instance method because that assumes the current instance is the target. Here, we must use the block variable. 

Of course, if we can use methods, then attributes are just methods to access instance values so we can use any true/false attribute as a condition too. This example shows how we can suppress a callback by setting a non-database attribute. If skip_geocode has been set to true, then it will not execute the for save geocode callback. 

Let's try some examples. Let's start with our after commit for cleaning reminder. Let's only execute that if there's too many records. So I'm going to make if, and I'll make a new method here too_many_records, but we need to then put that as a method somewhere down here, so I'll scroll to the bottom and let's define it. What is too many records? Well, let's say that if the task count is greater than four, then we have too many records. Let's set another one by going up here and using a proc. Let's do this one on the set_default_position, before_validation, set_position, and I'm going to jump to a new line here and indent if Proc.new and then I'll use a code block and I'll use a t to represent the current task and I'm going to check to see if task.position is blank or t.position is less than one. If we go down here and check set_default_position, it already had that condition built into it, so we don't need that anymore. We now know how to conditionally execute it from a proc instead. Now, there's nothing wrong with doing it the other way. You certainly could, but this makes it clear that this is not going to run when these conditions are met. And for titleize_name, let's make a new attribute accessor. I'm going to do this all the way at the very top just so it's very obvious right at the start, accessor, and I'm going to call it skip_titleize_name. And if that's set, then we're going to skip that callback. So here it is here. I'll add unless skip, use a colon in front of it, skip_titleize_name. So now let's go in our console and try these out, rails console. Let's create a new task, Task.new, and let's give it a name, task.name, is going to be equal to and we'll call it Wash car. I'm intentionally lowercasing the c there, task.save. Now it did save it. If I do task.name, we see that it did titleize it. If we look at the logs, you see that it did remember to prune old tasks because we do have more than four of them now. We could set it to a different value if we wanted to try it and see if it works without it. Let's just try the task name again. Let's set it to lowercase c one more time, but this time, let's do task.skip_titleize_name=true, task.save. Now this time when we say task.name, you see it did not. It skipped that callback because we'd set that value. Whichever way you choose to write these conditions, it's useful to be able to set conditions on when your callback should run.